// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: stock_price.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getStockPrice = `-- name: GetStockPrice :one
SELECT id, stock_code, price_date, closing_price, source_url, extracted_at FROM daily_stock_prices
WHERE stock_code = $1 AND price_date = $2 -- Use named args here too
LIMIT 1
`

type GetStockPriceParams struct {
	StockCode string
	PriceDate time.Time
}

func (q *Queries) GetStockPrice(ctx context.Context, arg GetStockPriceParams) (DailyStockPrice, error) {
	row := q.db.QueryRowContext(ctx, getStockPrice, arg.StockCode, arg.PriceDate)
	var i DailyStockPrice
	err := row.Scan(
		&i.ID,
		&i.StockCode,
		&i.PriceDate,
		&i.ClosingPrice,
		&i.SourceUrl,
		&i.ExtractedAt,
	)
	return i, err
}

const getStockPricesWithDetailsByCodeAndDateRange = `-- name: GetStockPricesWithDetailsByCodeAndDateRange :many
SELECT
    c.company_name,
    dsp.price_date,
    dsp.closing_price,
    dsp.stock_code -- Good to return for frontend mapping/debugging
FROM
    daily_stock_prices dsp
JOIN
    companies c ON dsp.stock_code = c.stock_code
WHERE
    dsp.stock_code = $1
    AND dsp.price_date >= $2
    AND dsp.price_date <= $3
ORDER BY
    dsp.price_date ASC
`

type GetStockPricesWithDetailsByCodeAndDateRangeParams struct {
	StockCode string
	StartDate time.Time
	EndDate   time.Time
}

type GetStockPricesWithDetailsByCodeAndDateRangeRow struct {
	CompanyName  string
	PriceDate    time.Time
	ClosingPrice string
	StockCode    string
}

func (q *Queries) GetStockPricesWithDetailsByCodeAndDateRange(ctx context.Context, arg GetStockPricesWithDetailsByCodeAndDateRangeParams) ([]GetStockPricesWithDetailsByCodeAndDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getStockPricesWithDetailsByCodeAndDateRange, arg.StockCode, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStockPricesWithDetailsByCodeAndDateRangeRow
	for rows.Next() {
		var i GetStockPricesWithDetailsByCodeAndDateRangeRow
		if err := rows.Scan(
			&i.CompanyName,
			&i.PriceDate,
			&i.ClosingPrice,
			&i.StockCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStockPrice = `-- name: UpsertStockPrice :exec
INSERT INTO daily_stock_prices (
    stock_code, price_date, closing_price, source_url, extracted_at
) VALUES (
    $1, $2, $3, $4, CURRENT_TIMESTAMP
)
ON CONFLICT (stock_code, price_date) DO UPDATE SET
    closing_price = EXCLUDED.closing_price,
    source_url = EXCLUDED.source_url,
    extracted_at = CURRENT_TIMESTAMP
`

type UpsertStockPriceParams struct {
	StockCode    string
	PriceDate    time.Time
	ClosingPrice string
	SourceUrl    sql.NullString
}

func (q *Queries) UpsertStockPrice(ctx context.Context, arg UpsertStockPriceParams) error {
	_, err := q.db.ExecContext(ctx, upsertStockPrice,
		arg.StockCode,
		arg.PriceDate,
		arg.ClosingPrice,
		arg.SourceUrl,
	)
	return err
}
