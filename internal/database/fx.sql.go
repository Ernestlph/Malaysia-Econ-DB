// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: fx.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getForeignExchangeByCurrencyAndDateRange = `-- name: GetForeignExchangeByCurrencyAndDateRange :many
SELECT
    date,
    middle_rate -- Adjust if you want other rates
FROM foreign_exchange
WHERE
    currency_code = $1 -- Explicitly name currency_code
    AND date >= $2        -- Explicitly name start_date
    AND date <= $3          -- Explicitly name end_date
ORDER BY
    date ASC
`

type GetForeignExchangeByCurrencyAndDateRangeParams struct {
	CurrencyCode string
	StartDate    time.Time
	EndDate      time.Time
}

type GetForeignExchangeByCurrencyAndDateRangeRow struct {
	Date       time.Time
	MiddleRate string
}

func (q *Queries) GetForeignExchangeByCurrencyAndDateRange(ctx context.Context, arg GetForeignExchangeByCurrencyAndDateRangeParams) ([]GetForeignExchangeByCurrencyAndDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getForeignExchangeByCurrencyAndDateRange, arg.CurrencyCode, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetForeignExchangeByCurrencyAndDateRangeRow
	for rows.Next() {
		var i GetForeignExchangeByCurrencyAndDateRangeRow
		if err := rows.Scan(&i.Date, &i.MiddleRate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertForeignExchange = `-- name: UpsertForeignExchange :exec
INSERT INTO foreign_exchange (
    id, currency_code, buying_rate, selling_rate, middle_rate, created_at, date
) VALUES (
    -- Name all parameters explicitly
    $1, $2, $3,
    $4, $5, $6, $7
)
ON CONFLICT (currency_code, date) DO UPDATE SET
    buying_rate = EXCLUDED.buying_rate,
    selling_rate = EXCLUDED.selling_rate,
    middle_rate = EXCLUDED.middle_rate,
    created_at = EXCLUDED.created_at
`

type UpsertForeignExchangeParams struct {
	ID           uuid.UUID
	CurrencyCode string
	BuyingRate   string
	SellingRate  string
	MiddleRate   string
	CreatedAt    time.Time
	Date         time.Time
}

func (q *Queries) UpsertForeignExchange(ctx context.Context, arg UpsertForeignExchangeParams) error {
	_, err := q.db.ExecContext(ctx, upsertForeignExchange,
		arg.ID,
		arg.CurrencyCode,
		arg.BuyingRate,
		arg.SellingRate,
		arg.MiddleRate,
		arg.CreatedAt,
		arg.Date,
	)
	return err
}
